<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>ğŸ„ æˆ‘ä»¬çš„è®°å¿†åœ£è¯æ ‘</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }

        /* é€€å‡ºæŒ‰é’® */
        #exit-btn {
            position: absolute; top: 20px; right: 20px;
            width: 40px; height: 40px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            color: white; text-decoration: none; font-size: 24px;
            z-index: 100; border: 1px solid rgba(255,255,255,0.2);
        }

        /* æç¤ºè¯­ */
        #instruction {
            position: absolute; bottom: 30px; width: 100%;
            text-align: center; color: rgba(255,255,255,0.6);
            font-size: 12px; letter-spacing: 2px;
            pointer-events: none; text-shadow: 0 0 10px black;
            animation: pulse 2s infinite;
        }

        @keyframes pulse { 0%, 100% { opacity: 0.4; } 50% { opacity: 1; } }

        /* åŠ è½½é¡µ */
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 999;
            display: flex; align-items: center; justify-content: center; flex-direction: column;
            color: #d4af37; transition: opacity 1s;
        }
    </style>
</head>
<body>
    <a href="/" id="exit-btn">Ã—</a>

    <div id="loading">
        <div style="font-size: 40px; margin-bottom: 20px;">âœ¨</div>
        <div style="font-size: 12px; letter-spacing: 2px;">æ­£åœ¨é‡‡é›†æ˜Ÿå…‰...</div>
    </div>

    <div id="instruction">åŒæŒ‡æåˆ / æ»šåŠ¨ / æ‘‡ä¸€æ‘‡</div>
    <div id="scene-container"></div>

    <!-- å¼•å…¥ Three.js åŠåæœŸå¤„ç†åº“ (å¿…é¡»æŒ‰é¡ºåº) -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        // === å…¨å±€å˜é‡ ===
        let scene, camera, renderer, composer, controls;
        let treePoints, photoMeshes = [], wishMeshes = [];
        let explosionProgress = 0; // 0 = æ ‘, 1 = çˆ†ç‚¸
        let targetProgress = 0;

        // æ•°æ®å®¹å™¨
        const photosData = [];
        const wishesData = [];

        // åˆå§‹åŒ–
        fetch('/api/christmas_data')
            .then(res => res.json())
            .then(data => {
                if(data.photos) data.photos.forEach(p => photosData.push(p));
                if(data.wishes) data.wishes.forEach(w => wishesData.push(w));
                init();
                animate();
            })
            .catch(err => {
                console.error(err);
                document.getElementById('loading').innerHTML = "åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°";
            });

        function init() {
            // 1. åœºæ™¯ä¸ç›¸æœº
            scene = new THREE.Scene();
            // èƒŒæ™¯è®¾ä¸ºææ·±çš„åˆå¤œè“ï¼Œé…åˆè¾‰å…‰æ›´å¥½çœ‹
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            // [ä¿®å¤] ç›¸æœºä½ç½®æ”¾ä½ä¸€ç‚¹ï¼Œå¹³è§†æ ‘èº«
            camera.position.set(0, 12, 35);

            renderer = new THREE.WebGLRenderer({ antialias: false }); // å¼€å¯Bloomæ—¶å»ºè®®å…³æŠ—é”¯é½¿ä»¥æå‡æ€§èƒ½
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.getElementById('scene-container').appendChild(renderer.domElement);

            // 2. æ§åˆ¶å™¨ (ç¦æ­¢ç¼©æ”¾ï¼Œå› ä¸ºç¼©æ”¾è¢«æˆ‘ä»¬è¦ç”¨æ¥åšç‰¹æ•ˆäº†)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableZoom = false; // [å…³é”®] ç¦ç”¨è‡ªå¸¦ç¼©æ”¾
            controls.enablePan = false;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 0.5;
            controls.target.set(0, 10, 0); // çœ‹å‘æ ‘çš„ä¸­å¿ƒ

            // 3. ç¯å…‰
            const ambient = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambient);
            const point = new THREE.PointLight(0xffaa00, 1.5, 100);
            point.position.set(0, 15, 10);
            scene.add(point);

            // 4. [æ ¸å¿ƒ] åˆ›å»ºè±ªååœ£è¯æ ‘
            createShaderTree();
            createFloatingPhotos();
            createGifts();

            // 5. åæœŸå¤„ç† (Bloom è¾‰å…‰ç‰¹æ•ˆ)
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2; // äº®åº¦è¶…è¿‡å¤šå°‘æ‰å‘å…‰
            bloomPass.strength = 1.2;  // å‘å…‰å¼ºåº¦
            bloomPass.radius = 0.5;    // å…‰æ™•åŠå¾„

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 6. äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onResize);
            // é¼ æ ‡æ»šè½® -> ç‚¸å¼€
            window.addEventListener('wheel', onWheel);
            // è§¦æ‘¸æ‰‹åŠ¿ -> ç‚¸å¼€
            setupTouchGestures();
            // æ‘‡ä¸€æ‘‡ -> ç‚¸å¼€
            setupShake();

            // ç§»é™¤åŠ è½½
            setTimeout(() => {
                document.getElementById('loading').style.opacity = 0;
                setTimeout(() => document.getElementById('loading').style.display='none', 1000);
            }, 1000);
        }

        // === æ ¸å¿ƒï¼šShader ç²’å­æ ‘ ===
        function createShaderTree() {
            const count = 3000; // ç²’å­æ•°é‡
            const geometry = new THREE.BufferGeometry();

            const positions = [];    // æ ‘å½¢æ€åæ ‡
            const chaosPos = [];     // çˆ†ç‚¸å½¢æ€åæ ‡
            const colors = [];
            const sizes = [];

            const colorGreen = new THREE.Color(0x10ac84);
            const colorGold = new THREE.Color(0xffd700);

            for(let i=0; i<count; i++) {
                // --- å½¢æ€1: æ ‘ (åœ†é”¥èºæ—‹) ---
                const y = Math.random() * 20;
                const rBase = 9 * (1 - y/22); // æ ‘åŠå¾„
                const angle = y * 5 + Math.random() * Math.PI * 2; // èºæ—‹ä¸Šå‡
                const r = rBase + (Math.random()-0.5) * 1.5; // éšæœºæŠ–åŠ¨

                const x = r * Math.cos(angle);
                const z = r * Math.sin(angle);

                positions.push(x, y, z);

                // --- å½¢æ€2: æ··æ²Œ (çƒå½¢çˆ†ç‚¸) ---
                const chaosR = 25 + Math.random() * 20;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                chaosPos.push(
                    chaosR * Math.sin(phi) * Math.cos(theta),
                    chaosR * Math.sin(phi) * Math.sin(theta),
                    chaosR * Math.cos(phi) + 10 // ä¸­å¿ƒæŠ¬é«˜
                );

                // --- é¢œè‰² ---
                // 80% ç»¿å¶, 20% é‡‘å…‰
                const isGold = Math.random() > 0.8;
                const color = isGold ? colorGold : colorGreen;
                colors.push(color.r, color.g, color.b);
                sizes.push(isGold ? 3.0 : 1.5);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('chaosPos', new THREE.Float32BufferAttribute(chaosPos, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            // è‡ªå®šä¹‰ç€è‰²å™¨
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uProgress: { value: 0 }, // 0=æ ‘, 1=çˆ†ç‚¸
                    pointTexture: { value: getTexture() }
                },
                vertexShader: `
                    uniform float uProgress;
                    uniform float uTime;
                    attribute vec3 chaosPos;
                    attribute float size;
                    varying vec3 vColor;

                    void main() {
                        vColor = color;
                        // åœ¨ æ ‘ä½ç½® å’Œ æ··æ²Œä½ç½® ä¹‹é—´æ’å€¼
                        vec3 pos = mix(position, chaosPos, uProgress);

                        // åŠ ä¸€ç‚¹å‘¼å¸åŠ¨æ•ˆ
                        pos.y += sin(uTime * 2.0 + position.x) * 0.1 * (1.0 - uProgress);

                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform sampler2D pointTexture;
                    varying vec3 vColor;
                    void main() {
                        gl_FragColor = vec4(vColor, 1.0);
                        gl_FragColor = gl_FragColor * texture2D(pointTexture, gl_PointCoord);
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            treePoints = new THREE.Points(geometry, material);
            scene.add(treePoints);
        }

        // === è¾…åŠ©ï¼šæ‚¬æµ®ç…§ç‰‡ ===
        function createFloatingPhotos() {
            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin('anonymous');

            photosData.forEach((p, i) => {
                // ç”¨ç®€å•çš„å¹³é¢ä»£æ›¿æ‹ç«‹å¾—ï¼Œæå‡æ€§èƒ½
                const geometry = new THREE.PlaneGeometry(3, 3); // ç…§ç‰‡å¤§ä¸€ç‚¹
                // é»˜è®¤ç°è‰²ï¼ŒåŠ è½½æˆåŠŸåæ›¿æ¢
                const material = new THREE.MeshBasicMaterial({ color: 0xcccccc, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(geometry, material);

                // èºæ—‹åˆ†å¸ƒ
                const y = 2 + (i / photosData.length) * 16;
                const r = 10 * (1 - y/25) + 1; // æµ®åœ¨æ ‘è¡¨é¢å¤–é¢ä¸€ç‚¹
                const angle = i * 1.5;

                // å­˜ä¸€ä¸‹ä¸¤ä¸ªçŠ¶æ€çš„ä½ç½®
                mesh.userData = {
                    treePos: new THREE.Vector3(r * Math.cos(angle), y, r * Math.sin(angle)),
                    chaosPos: new THREE.Vector3(
                        (Math.random()-0.5)*60,
                        (Math.random()-0.5)*60 + 10,
                        (Math.random()-0.5)*60
                    ),
                    randomRot: new THREE.Vector3(Math.random(), Math.random(), Math.random())
                };

                // åˆå§‹ä½ç½®
                mesh.position.copy(mesh.userData.treePos);
                mesh.lookAt(0, y, 0); // é¢å‘ä¸­å¿ƒ

                // å¼‚æ­¥åŠ è½½å›¾ç‰‡
                loader.load(p.url, (tex) => {
                    mesh.material.map = tex;
                    mesh.material.color.set(0xffffff); // å˜ç™½æ˜¾ç¤ºå›¾ç‰‡
                    mesh.material.needsUpdate = true;
                });

                scene.add(mesh);
                photoMeshes.push(mesh);
            });
        }

        // === è¾…åŠ©ï¼šç¤¼ç‰©ç›’ ===
        function createGifts() {
            // ... (ç®€åŒ–ç‰ˆç¤¼ç‰©é€»è¾‘ï¼Œä¸ºäº†æ€§èƒ½ä¸å†™å¤ªå¤æ‚) ...
            const geo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            wishesData.forEach((w, i) => {
                const mat = new THREE.MeshStandardMaterial({ color: w.color, roughness: 0.3, metalness: 0.8 });
                const box = new THREE.Mesh(geo, mat);
                const angle = Math.random() * 6.28;
                const r = 5 + Math.random() * 5;

                box.position.set(r*Math.cos(angle), -1, r*Math.sin(angle)); // æ”¾åœ¨åœ°ä¸Š
                box.userData = {
                    treePos: box.position.clone(),
                    chaosPos: new THREE.Vector3((Math.random()-0.5)*50, -10, (Math.random()-0.5)*50)
                };

                scene.add(box);
                wishMeshes.push(box);
            });
        }

        // === äº¤äº’é€»è¾‘ï¼šæ§åˆ¶ Progress ===

        // 1. é¼ æ ‡æ»šè½®
        function onWheel(e) {
            // å‘ä¸‹æ»š(æ­£æ•°) -> ç‚¸å¼€(1)ï¼›å‘ä¸Šæ»š -> è¿˜åŸ(0)
            targetProgress += e.deltaY * 0.001;
            targetProgress = Math.max(0, Math.min(1, targetProgress));
        }

        // 2. è§¦æ‘¸æ‰‹åŠ¿ (åŒæŒ‡æåˆ)
        function setupTouchGestures() {
            let initialDist = 0;

            window.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].pageX - e.touches[1].pageX;
                    const dy = e.touches[0].pageY - e.touches[1].pageY;
                    initialDist = Math.sqrt(dx*dx + dy*dy);
                }
            });

            window.addEventListener('touchmove', (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].pageX - e.touches[1].pageX;
                    const dy = e.touches[0].pageY - e.touches[1].pageY;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    // è·ç¦»å˜å¤§(æ‹‰å¼€) -> ç‚¸å¼€(1)
                    // è·ç¦»å˜å°(æåˆ) -> è¿˜åŸ(0)
                    const delta = (dist - initialDist) * 0.005;
                    targetProgress += delta;
                    targetProgress = Math.max(0, Math.min(1, targetProgress));
                    initialDist = dist; // æ›´æ–°åŸºå‡†
                    e.preventDefault(); // é˜²æ­¢é¡µé¢æ»šåŠ¨
                }
            });
        }

        // 3. æ‘‡ä¸€æ‘‡
        function setupShake() {
            let lastX=0, lastY=0, lastZ=0;
            window.addEventListener('devicemotion', (e) => {
                const acc = e.accelerationIncludingGravity;
                if(!acc) return;
                const deltaX = Math.abs(acc.x - lastX);
                const deltaY = Math.abs(acc.y - lastY);
                const deltaZ = Math.abs(acc.z - lastZ);

                // å‰§çƒˆæ™ƒåŠ¨
                if (deltaX + deltaY + deltaZ > 25) {
                    targetProgress = 1; // ç›´æ¥ç‚¸å¼€
                    // 3ç§’åè‡ªåŠ¨è¿˜åŸ
                    setTimeout(() => targetProgress = 0, 3000);
                }
                lastX = acc.x; lastY = acc.y; lastZ = acc.z;
            });
        }

        // === åŠ¨ç”»å¾ªç¯ ===
        function animate() {
            requestAnimationFrame(animate);

            // 1. å¹³æ»‘è¿‡æ¸¡çˆ†ç‚¸è¿›åº¦ (Lerp)
            explosionProgress += (targetProgress - explosionProgress) * 0.05;

            // 2. æ›´æ–° Shader æ ‘
            if (treePoints) {
                treePoints.material.uniforms.uProgress.value = explosionProgress;
                treePoints.material.uniforms.uTime.value = performance.now() / 1000;
            }

            // 3. æ›´æ–°ç…§ç‰‡ä½ç½®
            photoMeshes.forEach(mesh => {
                // åœ¨ æ ‘ä½ç½® å’Œ æ··æ²Œä½ç½® ä¹‹é—´æ’å€¼
                mesh.position.lerpVectors(mesh.userData.treePos, mesh.userData.chaosPos, explosionProgress);
                // æ—‹è½¬ä¹Ÿä¹±ä¸€ç‚¹
                if(explosionProgress > 0.1) {
                    mesh.rotation.x += 0.01;
                    mesh.rotation.y += 0.01;
                } else {
                    mesh.lookAt(0, mesh.position.y, 0); // å›å½’æ—¶é‡æ–°çœ‹å‘ä¸­å¿ƒ
                }
            });

            // 4. æ›´æ–°ç¤¼ç‰©
            wishMeshes.forEach(mesh => {
                 mesh.position.lerpVectors(mesh.userData.treePos, mesh.userData.chaosPos, explosionProgress);
                 if(explosionProgress > 0.1) mesh.rotation.y += 0.05;
            });

            // 5. å¦‚æœç‚¸å¼€äº†ï¼Œåœæ­¢è‡ªåŠ¨æ—‹è½¬æ–¹ä¾¿è§‚å¯Ÿ
            if (explosionProgress > 0.2) controls.autoRotate = false;
            else controls.autoRotate = true;

            controls.update();
            composer.render(); // ä½¿ç”¨åæœŸå¤„ç†æ¸²æŸ“
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // ç”Ÿæˆå‘å…‰ç²’å­çº¹ç† (ä¸ç”¨å¤–éƒ¨å›¾ç‰‡ï¼Œé˜²æ­¢è£‚å›¾)
        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0, 16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
    </script>
</body>
</html>