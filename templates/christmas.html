<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>ğŸ„ æˆ‘ä»¬çš„è®°å¿†åœ£è¯æ ‘</title>
    <style>
        /* [ä¿®æ”¹] èƒŒæ™¯æ”¹æˆæš–çº¢è‰²æ¸å˜ï¼Œä¸å†æ˜¯æ­»é»‘ */
        body {
            margin: 0; overflow: hidden;
            background: radial-gradient(circle at center, #6a1111 0%, #2c0505 100%);
            font-family: sans-serif;
        }

        #exit-btn {
            position: absolute; top: 20px; right: 20px;
            width: 40px; height: 40px;
            background: rgba(255,255,255,0.2);
            backdrop-filter: blur(5px);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            color: white; text-decoration: none; font-size: 24px;
            z-index: 100; border: 1px solid rgba(255,255,255,0.4);
        }

        #instruction {
            position: absolute; bottom: 40px; width: 100%;
            text-align: center; color: #ffd700;
            font-size: 14px; letter-spacing: 2px;
            pointer-events: none; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            animation: float 3s infinite ease-in-out;
        }

        @keyframes float { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-10px)} }

        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #4a0e0e; z-index: 999;
            display: flex; align-items: center; justify-content: center; flex-direction: column;
            color: #ffd700; transition: opacity 0.5s;
        }

        /* å¼¹çª—æ ·å¼ä¼˜åŒ– */
        #photo-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            display: none; align-items: center; justify-content: center; flex-direction: column;
            z-index: 200; backdrop-filter: blur(8px);
        }
        .polaroid-card {
            background: white; padding: 10px 10px 30px 10px;
            border-radius: 4px; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transform: rotate(-2deg); max-width: 80%;
            text-align: center;
        }
        #modal-img { max-width: 100%; max-height: 50vh; border: 1px solid #eee; }
        #modal-text { color: #333; margin-top: 15px; font-weight: bold; font-family: cursive; }
        #modal-date { color: #999; font-size: 12px; margin-top: 5px; }
    </style>
</head>
<body>
    <a href="/" id="exit-btn">Ã—</a>

    <div id="loading">
        <div style="font-size: 50px;">ğŸ</div>
        <div style="margin-top:10px;">æ­£åœ¨æ‹†å¼€ç¤¼ç‰©...</div>
    </div>

    <div id="instruction">âœ¨ åŒæŒ‡æåˆ / æ‘‡ä¸€æ‘‡ / æ»‘åŠ¨æ—‹è½¬ âœ¨</div>

    <!-- å¼¹çª— -->
    <div id="photo-modal" onclick="closeModal()">
        <div class="polaroid-card" onclick="event.stopPropagation()">
            <img id="modal-img" src="">
            <div id="modal-text"></div>
            <div id="modal-date"></div>
        </div>
    </div>

    <div id="scene-container"></div>

    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let photosGroup = new THREE.Group();
        let treeGroup = new THREE.Group(); // æ ‘çš„æ•´ä½“
        let particles; // ç²’å­ç³»ç»Ÿ

        let explosionProgress = 0;
        let targetProgress = 0;

        // å­˜å‚¨åˆå§‹ä½ç½®å’Œéšæœºä½ç½®
        const particlesData = []; // { originalPos, chaosPos }
        const photosData = []; // { originalPos, chaosPos, mesh }

        // 1. è·å–æ•°æ®
        fetch('/api/christmas_data')
            .then(res => res.json())
            .then(data => {
                init(data);
                animate();
            })
            .catch(err => {
                console.error(err);
                document.getElementById('loading').innerHTML = "åŠ è½½å¤±è´¥";
            });

        function init(data) {
            const container = document.getElementById('scene-container');
            scene = new THREE.Scene();
            // [ä¿®æ”¹] å»æ‰é›¾æ•ˆï¼Œä¿è¯æ¸…æ™°æ˜äº®

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 30);

            // [ä¿®æ”¹] å¼€å¯ alpha: true è®© CSS èƒŒæ™¯é€å‡ºæ¥
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableZoom = false; // ç¦ç”¨ç¼©æ”¾ï¼Œç•™ç»™ç‰¹æ•ˆç”¨
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;
            controls.target.set(0, 10, 0);

            // [ä¿®æ”¹] ç¯å…‰å¤§å¤§å¢å¼ºï¼Œä¸å†é˜´é—´
            const ambient = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambient);
            const dirLight = new THREE.DirectionalLight(0xffd700, 0.8);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // åˆ›å»ºæ ‘
            createBrightTree();

            // æŒ‚ç…§ç‰‡
            if (data.photos) {
                data.photos.forEach((p, i) => createPhoto(p, i, data.photos.length));
                treeGroup.add(photosGroup);
            }

            // å †ç¤¼ç‰©
            if (data.wishes) {
                createGifts(data.wishes);
            }

            scene.add(treeGroup);

            // äº¤äº’
            setupInteractions();

            // ç§»é™¤ Loading
            setTimeout(() => {
                document.getElementById('loading').style.opacity = 0;
                setTimeout(()=>document.getElementById('loading').style.display='none', 500);
            }, 800);
        }

        // === 1. åˆ›å»ºæ˜äº®çš„ç²’å­æ ‘ ===
        function createBrightTree() {
            const geometry = new THREE.BufferGeometry();
            const count = 2500;
            const positions = [];
            const colors = [];

            const colorGreen = new THREE.Color(0x2ecc71); // é²œè‰³ç»¿
            const colorGold = new THREE.Color(0xfff200);  // äº®é‡‘è‰²

            for(let i=0; i<count; i++) {
                const y = Math.random() * 20;
                const radius = 8 * (1 - y/21);
                const angle = y * 6 + Math.random() * Math.PI * 2;

                // æ ‘å½¢åæ ‡
                const x = radius * Math.cos(angle);
                const z = radius * Math.sin(angle);

                positions.push(x, y, z);

                // æ··æ²Œåæ ‡ (ç‚¸å¼€åçš„ä½ç½®)
                particlesData.push({
                    treeVec: new THREE.Vector3(x, y, z),
                    chaosVec: new THREE.Vector3(
                        (Math.random()-0.5)*50,
                        (Math.random()-0.5)*50 + 10,
                        (Math.random()-0.5)*50
                    )
                });

                // é¢œè‰²
                const isGold = Math.random() > 0.85;
                const c = isGold ? colorGold : colorGreen;
                colors.push(c.r, c.g, c.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // [ä¿®æ”¹] ä½¿ç”¨ PointsMaterialï¼Œä¸ç”¨ Shaderï¼Œä¿è¯äº®åº¦å’Œå…¼å®¹æ€§
            const material = new THREE.PointsMaterial({
                size: 0.4,
                vertexColors: true,
                map: getCircleTexture(),
                transparent: true,
                alphaTest: 0.5
            });

            particles = new THREE.Points(geometry, material);
            treeGroup.add(particles);

            // æ ‘é¡¶å¤§æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.SphereGeometry(0.8, 8, 8);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // è‡ªå‘å…‰
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, 20.5, 0);
            treeGroup.add(star);
        }

        // === 2. åˆ›å»ºæ˜äº®çš„ç…§ç‰‡ ===
        function createPhoto(data, index, total) {
            const loader = new THREE.TextureLoader();
            loader.setCrossOrigin('anonymous');

            // æ‹ç«‹å¾—ç™½æ¡†
            const frameGeo = new THREE.PlaneGeometry(2.2, 2.6);
            // [ä¿®æ”¹] ä½¿ç”¨ BasicMaterialï¼Œä¸å—å…‰ç…§å½±å“ï¼Œæ°¸è¿œäº®ç™½
            const frameMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const frame = new THREE.Mesh(frameGeo, frameMat);

            // èºæ—‹ä½ç½®
            const y = 1.5 + (index/total) * 17;
            const r = 8 * (1 - y/22) + 0.8;
            const angle = index * 1.5;

            const treePos = new THREE.Vector3(r*Math.cos(angle), y, r*Math.sin(angle));
            const chaosPos = new THREE.Vector3((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60);

            frame.position.copy(treePos);
            frame.lookAt(0, y, 0);

            // ç»‘å®šæ•°æ®
            frame.userData = {
                isPhoto: true,
                info: data,
                treePos: treePos,
                chaosPos: chaosPos,
                treeRot: frame.rotation.clone(),
                chaosRot: new THREE.Euler(Math.random()*6, Math.random()*6, Math.random()*6)
            };

            // åŠ è½½å›¾ç‰‡
            loader.load(data.url, (tex) => {
                const imgGeo = new THREE.PlaneGeometry(1.8, 1.8);
                const imgMat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
                const img = new THREE.Mesh(imgGeo, imgMat);
                img.position.y = 0.2;
                img.position.z = 0.01;
                frame.add(img);
            });

            photosGroup.add(frame);
            photosData.push(frame); // å­˜å…¥æ•°ç»„æ–¹ä¾¿åŠ¨ç”»
        }

        // === 3. ç®€å•çš„ç¤¼ç‰©ç›’ ===
        function createGifts(wishes) {
            wishes.forEach(w => {
                const geo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
                const mat = new THREE.MeshBasicMaterial({ color: w.color }); // è‡ªå‘å…‰
                const box = new THREE.Mesh(geo, mat);
                const r = 3 + Math.random()*5;
                const a = Math.random()*6.28;
                box.position.set(r*Math.cos(a), -0.5, r*Math.sin(a));
                box.rotation.y = Math.random();

                // ç¤¼ç‰©æ•°æ®
                box.userData = { isGift: true, text: w.content };
                // ç¤¼ç‰©ä¹Ÿå‚ä¸çˆ†ç‚¸
                box.userData.treePos = box.position.clone();
                box.userData.chaosPos = new THREE.Vector3((Math.random()-0.5)*40, -10, (Math.random()-0.5)*40);

                treeGroup.add(box);
                photosData.push(box); // å€Ÿç”¨ç…§ç‰‡æ•°ç»„ä¸€èµ·åŠ¨
            });
        }

        // === äº¤äº’é€»è¾‘ ===
        function setupInteractions() {
            // 1. æ‘‡ä¸€æ‘‡
            let lastX=0, lastY=0, lastZ=0;
            window.addEventListener('devicemotion', (e) => {
                const acc = e.accelerationIncludingGravity;
                if(!acc) return;
                const delta = Math.abs(acc.x+acc.y+acc.z - lastX-lastY-lastZ);
                if(delta > 20) triggerExplosion();
                lastX=acc.x; lastY=acc.y; lastZ=acc.z;
            });

            // 2. åŒæŒ‡/æ»šè½®
            let initialDist = 0;
            window.addEventListener('touchstart', e => {
                if(e.touches.length===2) {
                    const t1=e.touches[0], t2=e.touches[1];
                    initialDist = Math.hypot(t1.pageX-t2.pageX, t1.pageY-t2.pageY);
                }
            });
            window.addEventListener('touchmove', e => {
                if(e.touches.length===2) {
                    const t1=e.touches[0], t2=e.touches[1];
                    const dist = Math.hypot(t1.pageX-t2.pageX, t1.pageY-t2.pageY);
                    if(dist - initialDist > 50) targetProgress = 1; // æ‹‰å¼€ -> ç‚¸
                    if(dist - initialDist < -50) targetProgress = 0; // æåˆ -> èš
                    e.preventDefault();
                }
            }, {passive: false});

            window.addEventListener('wheel', e => {
                targetProgress += e.deltaY * 0.001;
                targetProgress = Math.max(0, Math.min(1, targetProgress));
            });

            // 3. ç‚¹å‡»æŸ¥çœ‹
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            window.addEventListener('click', e => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(treeGroup.children, true);

                if(intersects.length > 0) {
                    let obj = intersects[0].object;
                    if(obj.parent.userData.isPhoto) obj = obj.parent; // é€‰ä¸­ç›¸æ¡†

                    if(obj.userData.isPhoto) {
                        showModal(obj.userData.info);
                        controls.autoRotate = false;
                    } else if(obj.userData.isGift) {
                        alert("ğŸ æ„¿æœ›: " + obj.userData.text);
                    }
                } else {
                    controls.autoRotate = true; // ç‚¹ç©ºç™½å¤„æ¢å¤æ—‹è½¬
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function triggerExplosion() {
            targetProgress = 1;
            setTimeout(() => targetProgress = 0, 3000);
        }

        function showModal(info) {
            document.getElementById('modal-img').src = info.url;
            document.getElementById('modal-text').innerText = info.text || "æ¸©é¦¨ç¬é—´";
            document.getElementById('modal-date').innerText = info.date || "";
            document.getElementById('photo-modal').style.display = 'flex';
        }

        window.closeModal = function() {
            document.getElementById('photo-modal').style.display = 'none';
            controls.autoRotate = true;
        }

        function getCircleTexture() {
            const c = document.createElement('canvas');
            c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(16,16,14,0,Math.PI*2);
            ctx.fill();
            const t = new THREE.Texture(c);
            t.needsUpdate = true;
            return t;
        }

        // === åŠ¨ç”»å¾ªç¯ ===
        function animate() {
            requestAnimationFrame(animate);

            // å¹³æ»‘æ’å€¼
            explosionProgress += (targetProgress - explosionProgress) * 0.05;

            // 1. ç²’å­è¿åŠ¨
            const positions = particles.geometry.attributes.position.array;
            for(let i=0; i<particlesData.length; i++) {
                const d = particlesData[i];
                // ç®€å•çš„çº¿æ€§æ’å€¼ (Lerp)
                const x = d.treeVec.x + (d.chaosVec.x - d.treeVec.x) * explosionProgress;
                const y = d.treeVec.y + (d.chaosVec.y - d.treeVec.y) * explosionProgress;
                const z = d.treeVec.z + (d.chaosVec.z - d.treeVec.z) * explosionProgress;

                positions[i*3] = x;
                positions[i*3+1] = y;
                positions[i*3+2] = z;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // 2. ç…§ç‰‡è¿åŠ¨
            photosData.forEach(mesh => {
                if(mesh.userData.treePos) {
                    mesh.position.lerpVectors(mesh.userData.treePos, mesh.userData.chaosPos, explosionProgress);
                    // æ—‹è½¬æ’å€¼ (è¿™é‡Œç®€å•å¤„ç†ï¼Œç‚¸å¼€æ—¶éšæœºè½¬ï¼Œå›æ¥æ—¶å›æ­£)
                    if(explosionProgress > 0.1) {
                        mesh.rotation.x += 0.02;
                        mesh.rotation.y += 0.02;
                    } else {
                        // ç®€å•åœ°è®©å®ƒçœ‹å‘åŸç‚¹ï¼Œæ¯”æ’å€¼å››å…ƒæ•°æ›´çœäº‹
                        mesh.lookAt(0, mesh.position.y, 0);
                    }
                }
            });

            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>