<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>ğŸ„ ä¸“å±è®°å¿†åœ£è¯æ ‘</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: sans-serif; }

        /* é€€å‡ºæŒ‰é’® */
        #exit-btn {
            position: absolute; top: 20px; right: 20px;
            width: 40px; height: 40px;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(5px);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            color: white; text-decoration: none; font-size: 24px;
            z-index: 100; border: 1px solid rgba(255,255,255,0.2);
        }

        /* åŠ è½½é¡µ */
        #loading {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #050510;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            color: #ffd700; z-index: 999; transition: opacity 1s;
        }
        .loader-text { margin-top: 20px; font-size: 14px; opacity: 0.8; letter-spacing: 2px; }

        /* ç‚¹å‡»ç…§ç‰‡åçš„å¼¹çª— */
        #photo-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: none; align-items: center; justify-content: center; flex-direction: column;
            z-index: 200; backdrop-filter: blur(10px);
        }
        #modal-img { max-width: 85%; max-height: 60%; border: 5px solid white; border-radius: 4px; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #modal-text { color: white; margin-top: 20px; font-size: 16px; font-weight: bold; text-align: center; max-width: 80%; }
        #modal-date { color: #aaa; font-size: 12px; margin-top: 5px; }
        #modal-close { margin-top: 30px; color: white; border: 1px solid white; padding: 5px 20px; border-radius: 20px; cursor: pointer; }
    </style>
</head>
<body>
    <a href="/" id="exit-btn">Ã—</a>

    <div id="loading">
        <div style="font-size: 50px; animation: bounce 1s infinite;">ğŸ„</div>
        <div class="loader-text">æ­£åœ¨ç¼–ç»‡è¿™ä¸€å¹´çš„å›å¿†...</div>
    </div>

    <!-- ç…§ç‰‡è¯¦æƒ…å¼¹çª— -->
    <div id="photo-modal">
        <img id="modal-img" src="">
        <div id="modal-text"></div>
        <div id="modal-date"></div>
        <div id="modal-close" onclick="closeModal()">å…³é—­</div>
    </div>

    <div id="scene-container"></div>

    <!-- å¼•å…¥ Three.js å…¨å®¶æ¡¶ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- TWEEN ç”¨äºå¹³æ»‘åŠ¨ç”» -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let photosGroup = new THREE.Group();
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();

        // 1. è·å–æ•°æ®
        fetch('/api/christmas_data')
            .then(res => res.json())
            .then(data => {
                init3D(data);
                animate();
            })
            .catch(err => {
                console.error(err);
                document.querySelector('.loader-text').innerText = "åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é‡è¯•";
            });

        function init3D(data) {
            // === åœºæ™¯åˆå§‹åŒ– ===
            const container = document.getElementById('scene-container');
            scene = new THREE.Scene();
            // é›¾æ•ˆï¼Œåˆ¶é€ æ·±é‚ƒæ„Ÿ
            scene.fog = new THREE.FogExp2(0x050510, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 10, 25); // åˆå§‹ç›¸æœºä½ç½®

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true; // è‡ªåŠ¨æ—‹è½¬ï¼Œå±•ç¤ºå…¨è²Œ
            controls.autoRotateSpeed = 1.0;

            // === ç¯å…‰ ===
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffd700, 1, 50);
            pointLight.position.set(0, 10, 10);
            scene.add(pointLight);

            // === A. æ ‘çš„ä¸»ä½“ (ç²’å­ç³»ç»Ÿ) ===
            createParticleTree();

            // === B. æŒ‚ç…§ç‰‡ (Polaroids) ===
            if (data.photos && data.photos.length > 0) {
                data.photos.forEach((photo, index) => {
                    createPolaroid(photo, index, data.photos.length);
                });
                scene.add(photosGroup);
            }

            // === C. å †ç¤¼ç‰© (Wishes) ===
            if (data.wishes) {
                data.wishes.forEach((wish, index) => {
                    createGiftBox(wish, index, data.wishes.length);
                });
            }

            // === D. åœ°é¢åå°„ (è¥é€ æ°›å›´) ===
            const groundGeo = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshBasicMaterial({ color: 0x050510 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            scene.add(ground);

            // äº¤äº’ç›‘å¬
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('click', onMouseClick, false);
            window.addEventListener('touchstart', onTouchStart, false); // æ‰‹æœºè§¦æ‘¸å…¼å®¹

            // éšè—åŠ è½½å±‚
            setTimeout(() => {
                const loading = document.getElementById('loading');
                loading.style.opacity = 0;
                setTimeout(() => loading.style.display = 'none', 1000);
            }, 1500);
        }

        // åˆ›å»ºç²’å­æ ‘ (æ•°å­¦é­”æ³•)
        function createParticleTree() {
            const particleCount = 1500;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            const colorGreen = new THREE.Color(0x2ecc71);
            const colorGold = new THREE.Color(0xffd700);

            for (let i = 0; i < particleCount; i++) {
                // æ ‘é«˜ 20ï¼Œåº•éƒ¨åŠå¾„ 8
                const y = Math.random() * 20;
                const radius = 8 * (1 - y / 20); // è¶Šé«˜è¶Šçª„
                const angle = Math.random() * Math.PI * 2;

                // åŠ ä¸Šä¸€ç‚¹éšæœºæŠ–åŠ¨ï¼Œè®©æ ‘çœ‹èµ·æ¥è‡ªç„¶è“¬æ¾
                const r = radius + (Math.random() - 0.5) * 2;
                const x = r * Math.cos(angle);
                const z = r * Math.sin(angle);

                positions.push(x, y, z);

                // 90% ç»¿è‰²ï¼Œ10% é‡‘è‰²ç¯å…‰
                const color = Math.random() > 0.9 ? colorGold : colorGreen;
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });

            const tree = new THREE.Points(geometry, material);
            scene.add(tree);

            // æ ‘é¡¶æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.SphereGeometry(0.5, 8, 8);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.set(0, 20.5, 0);
            scene.add(star);

            // æ˜Ÿæ˜Ÿé—ªçƒåŠ¨ç”»
            new TWEEN.Tween(star.scale)
                .to({ x: 1.5, y: 1.5, z: 1.5 }, 1000)
                .yoyo(true).repeat(Infinity).start();
        }

        // åˆ›å»ºæ‹ç«‹å¾—ç…§ç‰‡
        function createPolaroid(photoData, index, total) {
            const loader = new THREE.TextureLoader();
            // å…è®¸è·¨åŸŸåŠ è½½å›¾ç‰‡
            loader.setCrossOrigin('anonymous');

            loader.load(photoData.url, (texture) => {
                // æ‹ç«‹å¾—ç›¸çº¸ (ç™½åº•)
                const frameGeo = new THREE.PlaneGeometry(1.2, 1.5);
                const frameMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                const frame = new THREE.Mesh(frameGeo, frameMat);

                // ç…§ç‰‡å†…å®¹
                const imgGeo = new THREE.PlaneGeometry(1, 1);
                const imgMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                const img = new THREE.Mesh(imgGeo, imgMat);
                img.position.z = 0.01; // ç¨å¾®çªèµ·ä¸€ç‚¹ï¼Œé˜²æ­¢é‡å é—ªçƒ
                img.position.y = 0.15; // æ”¾åœ¨ç›¸çº¸ä¸Šéƒ¨

                frame.add(img);

                // ç»‘å®šæ•°æ®ç”¨äºç‚¹å‡»äº‹ä»¶
                frame.userData = { isPhoto: true, info: photoData };

                // èºæ—‹æ’å¸ƒç®—æ³•
                const y = 2 + (index / total) * 16; // åˆ†å¸ƒåœ¨é«˜åº¦ 2~18 ä¹‹é—´
                const radius = 8 * (1 - y / 20) + 0.5; // è´´åœ¨æ ‘è¡¨é¢
                const angle = index * 1.5; // èºæ—‹è§’åº¦

                frame.position.set(
                    radius * Math.cos(angle),
                    y,
                    radius * Math.sin(angle)
                );

                // è®©ç…§ç‰‡å§‹ç»ˆé¢å‘åœ†å¿ƒï¼ˆæˆ–è€…ç¨å¾®éšæœºä¸€ç‚¹ï¼‰
                frame.lookAt(0, y, 0);
                // å†éšæœºæ­ªä¸€ç‚¹ï¼Œæ›´è‡ªç„¶
                frame.rotateZ((Math.random() - 0.5) * 0.5);

                photosGroup.add(frame);
            });
        }

        // åˆ›å»ºç¤¼ç‰©ç›’
        function createGiftBox(wish, index, total) {
            const size = 0.8 + Math.random() * 0.5;
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshStandardMaterial({ color: wish.color });
            const box = new THREE.Mesh(geometry, material);

            // éšæœºæ•£è½åœ¨æ ‘åº•ä¸‹ (åŠå¾„ 3~7 ä¹‹é—´)
            const angle = Math.random() * Math.PI * 2;
            const radius = 3 + Math.random() * 4;

            box.position.set(
                radius * Math.cos(angle),
                size / 2 - 2, // æ”¾åœ¨åœ°é¢ä¸Š
                radius * Math.sin(angle)
            );

            box.rotation.y = Math.random() * Math.PI;

            // ç‚¹å‡»æ•°æ®
            box.userData = { isGift: true, text: wish.content };

            scene.add(box);
        }

        // === äº¤äº’é€»è¾‘ ===
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onTouchStart(event) {
            // ç®€å•çš„è§¦æ‘¸ç‚¹å‡»å…¼å®¹
            if (event.touches.length === 1) {
                event.preventDefault(); // é˜²æ­¢æ»šåŠ¨
                mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
                checkIntersection();
            }
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            checkIntersection();
        }

        function checkIntersection() {
            raycaster.setFromCamera(mouse, camera);

            // æ£€æµ‹ç…§ç‰‡
            const intersectsPhotos = raycaster.intersectObjects(photosGroup.children, true);
            if (intersectsPhotos.length > 0) {
                // æ‰¾åˆ°æœ€è¿‘çš„é‚£ä¸ª
                let target = intersectsPhotos[0].object;
                // å¦‚æœç‚¹åˆ°çš„æ˜¯é‡Œé¢çš„å›¾ç‰‡ï¼Œå–çˆ¶çº§(ç›¸æ¡†)
                if (!target.userData.isPhoto && target.parent && target.parent.userData.isPhoto) {
                    target = target.parent;
                }

                if (target.userData.isPhoto) {
                    showModal(target.userData.info);
                    // æš‚åœæ—‹è½¬æ–¹ä¾¿çœ‹å›¾
                    controls.autoRotate = false;
                }
                return;
            }

            // æ£€æµ‹ç¤¼ç‰©
            const intersectsScene = raycaster.intersectObjects(scene.children);
            for (let i = 0; i < intersectsScene.length; i++) {
                if (intersectsScene[i].object.userData.isGift) {
                    alert("ğŸ æ„¿æœ›ç›’å­ï¼š\n" + intersectsScene[i].object.userData.text);
                    return;
                }
            }

            // å¦‚æœç‚¹åˆ°ç©ºç™½å¤„ï¼Œæ¢å¤æ—‹è½¬
            controls.autoRotate = true;
        }

        function showModal(info) {
            const modal = document.getElementById('photo-modal');
            const img = document.getElementById('modal-img');
            const text = document.getElementById('modal-text');
            const date = document.getElementById('modal-date');

            img.src = info.url;
            text.innerText = info.text || "ç¾å¥½ç¬é—´";
            date.innerText = info.date || "";

            modal.style.display = 'flex';
        }

        window.closeModal = function() {
            document.getElementById('photo-modal').style.display = 'none';
            controls.autoRotate = true; // æ¢å¤æ—‹è½¬
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>